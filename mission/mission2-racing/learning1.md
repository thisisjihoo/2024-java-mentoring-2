# 인터페이스
- 극단적으로 동일한 목적 하에 동일한 기능을 수행하게끔 강제하는 것
- 자바의 다형성을 극대화하여 개발코드 수정을 줄이고 프로그램 유지보수성을 높이기 위해 인터페이스를 사용한다.
- 사용방법
  - interface 키워드를 통해 선언한다. 
  - implements 키워드를 통해 일반 클래스에서 인터페이스 구현.

public interface 인터페이스명 {

//상수
타입 상수명 = 값;

//추상 메소드
타입 메소드명(매개변수, ... );

//디폴트 메소드
default 타입 메소드명(매개변수, ... ){
    //구현부
    }

//정적 메소드
static 타입 메소드명(매개변수) {
    //구현부
    }

}

상수: 인터페이스에서 값을 정해줌. (절대적)
추상 메소드: 가이드 제공. 추상 메소드를 오버라이팅해서 재구현. (강제적)
디폴트 메소드: 인터페이스에서 기본적으로 제공. 구현 가능(선택적)
정적 메소드: 인터페이스에서 제공해주는 것으로 무조건 사용. (절대적)

# 원시값 포장
- primitive 타입을 그대로 사용하지 않고, 객체로 사용하기 위해 하나의 클래스를 선언해 원시 타입의 값을 의미 있는 객체로 포장하는 것.
- 스스로 상태를 관리하게 되어 책임을 분리할 수 있다.
- 모든 원시값과 문자열을 포장한다.
  - 원시 타입?
    - 문자
    - 다양한 산술 정밀도를 갖는 정수
    - 부동소수점수
    - 참, 거짓 -> boolean
    - 참조
  - 사용하는 이유
    - 예외처리를 자신 스스로 할 수 있게 책임을 부여 -> 유지 보수를 위해!
    - 갹체에게 자율성을 제공할 수 있다.
  - 단점
    - 성능이 저하되고 불필요한 객체가 생성된다.
    - 원시값을 객체로 포장하면 메모리 사용량이 늘어난다.

# 객체 지향의 5가지 원칙 SOLID
- 단일 책임 원칙
- 개방 폐쇄 원칙
- 리스코프 치환 원칙
- 인터페이스 분리 원칙
- 의존 역전 원칙
  - SOLID 원칙을 적용하면 좋은 점
    - 코드를 확장하고, 유지 보수 관리하기가 더 쉬워짐
    - 불필요한 복잡성을 제거해 리팩토링에 소요되는 시간을 줄임으로써 프로젝트 개발의 생산성을 높일 수 있음.

    # 단일 책임 원칙
    : 클래스(객체)는 단 하나의 책임만 가져야한다.
        - 여기서 책임의 의미는 하나의 '기능 담당'
        - 프로그램의 유지보수성을 높이기 위한 설계 기법        
        - 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로따로 파야한다.
  
    # 개방 폐쇄 원칙
    : 확장에 열려있어야하며, 수정에는 닫혀있어야 한다.
    : 추상화 사용을 통한 관계 구축을 권장
        - 추가 기능 요청시 클래스 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화.
        - [확장에 열려있다] -> 새로운 변경 사항이 발생했을 때 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 애플리케이션의 기능을 확장할 수 있음
        - [변경에 닫혀있따] -> 새로운 변경 사항이 발생했을 때 객체를 직접적으로 수정을 제한함.
  
    # 리스코프 치환 원칙
    : 서브 타입은 언제나 기반(부모) 타입으로 교체할 수 있어야 한다.
    : 다형성 원리를 이용하기 위한 원칙
        - 업캐스팅 상태에서 부모의 매서드를 사용해도 동작이 의도대로 흘러가야 한다.
  
    # 인터페이스 분리 원칙
    : 인터페이스를 각각 사용에 맞게 끔 잘게 분리해야하는 원칙
    : 인터페이스의 단일 책임을 강조
        - 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공하는 것이 목표.
        - 한번 인터페이스를 분리하여 구성해놓고 나중에 무언가 수정사항이 생겨서 또 인터페이스들ㅇ르 분리하는 행위 XXXX
  
    # 의존 역전 원칙
    : 클래스를 직접 참조하는 것이 아닌 그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙
        - 인터페이스에 의존하라는 뜻
        - 변화하기 어려운 것 거의 변화가 없는 것에 의존하라.

# 캡슐화
- 객체의 속성과 메서드를 하나로 묶어 외부로부터의 직접적인 접근을 제한하고, 해당 객체의 매서드를 통해서만 변경이 가능하도록 하는 것.
    
    # 캡슐화를 적용하는 이유
    - 정보 은닉
        - 클래스의 내부 구현을 외부로부터 숨기게 된다면 클래스의 사용자는 내부 구현에 대해 알 필요 없이 인터페이스(프로토콜)를 통해 클래스를 사용할 수 있다.
    - 재사용성
      - 독립적인 모듈을 만들어 다른 곳에서 재사용할 수 있다.
    - 유지보수
      - 해당 클래스가 어떻게 구현되었는지 알 필요 없이 그 클래스를 사용하거나 수정할 수 있다.
    - 안정성
        - 어느 객체가 잘못된 방법으로 상태를 변경하면서 발생할 수 있는 오류를 방지할 수 있습니다.


# VO
- 도메인에서 한 개 또는 그 이상의 속성들을 묶어서 특정 값을 나타내는 객체(해당 속성들은 primitive 타입이다.)
  - 불변성: 수정자(setter)가 없다
  - 값 동등성: 내부 값 동등성 검사
  - 자가유효성 검사: 생성자에서 validate
  - vo를 사용하는 이유?
    - primitive 타입이 도메인 객체를 모델링하기 위해 충분하지 않기 때문
    
# DAO
- DB의 데이터에 접근하기 위한 객체를 가리킴
- DB에 접근하기 위한 로직을 분리하기 위해 사용한다. 
- 직접 DB에 접근하여, data를 삽입, 삭제, 조회 등 조작할 수 있는 기능을 수행한다.

# DTO
- 계층 간 데이터 교환을 위한 Java Bean를 의미한다.
- 로직을 가지지 않는 데이터 객체이다.
- getter, setter 메소드만 가진 클래스를 의미한다.

# VO
- Read-Only 속성을 가진 값 오브젝트이다.
- getter 기능만 존재한다.

# 오버로딩(Overloading)
- 자바의 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메소드를 정의할 수 있다.
  - 오버로딩의 조건
    - 메소드의 이름이 같고, 매개변수의 개수나 타입이 달라야한다.
    - '리턴 값만' 다른 것은 오버로딩을 할 수 없다.
    - 접근 제어자도 자유롭게 지정해줄 수 있다.
    - 오버로딩은 매개변수의 차이로만 구현 가능!
  - 오버로딩을 사용하는 이유
    1. 같은 기능을 하는 메소드를 하나의 이름으로 사용할 수 있다.(ex. println)
    2. 메소드의 이름을 절약할 수 있다.

# 오버라이딩(Overriding)
- 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하는 것
- 상속 받은 메소드를 그대로 사용할 수도 있지만 자식 클래스에서 상황에 맞게 변경하는 것도 가능
  - 오버라이딩의 조건
    - 부모 클래스의 메소드를 재정의 하는 것이므로, 자식 클래스에서는 오버라이딩 하고자 하는 메소드의 '이름', '매개변수', '리턴 값'이 모두 같아야한다.
  - @Overrid 
    - 어노테이션, 주석.
    - 검증하는 기능을 함
    - 선언부는 부모의 것과 완벽히 동일해야함.

# 오버로딩 vs 오버라이딩
- 오버로딩: 기존에 없는 새로운 메소드를 추가하는 것
- 오버라이딩: 상속받은 메소드를 재정의 하는 것

# 인터페이스를 통한 확장성 증가
- 유연한 코드 확장 및 유지보수 용이: 클래스를 독립적으로 변경할 수 있다.
- 다형성 지원: 특정 구현체에 의존하지 않고 유연한 코드 작성이 가능하다.
- 의존성 감소 및 결합도를 낮춤: 인터페이스 자체에 의존하도록 설계를 하기 때문에 클래스 간 결합도를 낮춘다.

# enum
- 클래스처럼 보이게 하는 상수
- 서로 관련있는 상수들끼리 모아 상수들을 정의하는 것
- enum 클래스 형을 기반으로 한 클래스형 선언
  - 특징
    1. 열겨형으로 선언된 순서에 따라 0부터 index 값을 가진다.(순차적으로 증가)
    2. enum 열거형으로 지정된 상수들은 모두 대문자로 선언한다.
    3. 열거형 변수들을 선언한 후 마지막에 세미콜론(;)을 찍지 않는다
    4. 상수와 특정 값을 연결시킬 경우 마지막에 세미콜론(;)을 붙여줘야 한다.
